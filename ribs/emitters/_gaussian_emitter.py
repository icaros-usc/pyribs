"""Provides the GaussianEmitter and corresponding GaussianEmitterConfig."""
import numpy as np

from ribs.config import create_config


class GaussianEmitterConfig:
    """Configuration for the GaussianEmitter.

    Args:
        seed (float or int): Value to seed the random number generator. Set to
            None to avoid seeding. Default: None
        batch_size (int): Number of solutions to send back in the ask() method.
            Default: 64
    """

    def __init__(
        self,
        seed=None,
        batch_size=64,
    ):
        self.seed = seed
        self.batch_size = batch_size


class GaussianEmitter:
    """Emits solutions by adding Gaussian noise to existing archive solutions.

    If the archive is empty, calls to ask() will generate solutions from a
    user-specified Gaussian distribution with mean ``x0`` and standard deviation
    ``sigma0``. Otherwise, this emitter selects solutions from the archive and
    generates solutions from a Gaussian distribution centered around each
    solution with standard deviation ``sigma0``.

    Args:
        x0 (array-like): Center of the Gaussian distribution from which to
            sample solutions when the archive is empty.
        sigma0 (float or array-like): Standard deviation of the Gaussian
            distribution, both when the archive is empty and afterwards. Note we
            assume the Gaussian is diagonal, so this argument can only be 1D if
            it is an array.
        archive (ribs archive): An archive to use when creating and inserting
            solutions. For instance, this can be
            :class:`ribs.archives.GridArchive`.
        config (None or dict or GaussianEmitterConfig): Configuration object. If
            None, a default GaussianEmitterConfig is constructed. A dict may
            also be passed in, in which case its arguments will be passed into
            GaussianEmitterConfig.
    Attributes:
        config (GaussianEmitterConfig): Configuration object.
        x0 (np.ndarray): See args.
        sigma0 (np.ndarray): See args.
        archive (ribs archive): See args.
        batch_size (int): Number of solutions to generate on each call to ask().
            Passed in via ``config.batch_size``.
    """

    def __init__(self, x0, sigma0, archive, config=None):
        self.config = create_config(config, GaussianEmitterConfig)
        self._rng = np.random.default_rng(self.config.seed)

        self.x0 = np.array(x0)
        self.sigma0 = np.array(sigma0)
        self.archive = archive
        self.batch_size = self.config.batch_size

    def ask(self):
        """Generates ``self.batch_size`` solutions.

        If the archive is empty, solutions are drawn from a (diagonal) Gaussian
        distribution centered at ``self.x0``. Otherwise, each solution is drawn
        from a distribution centered at a randomly chosen elite. In either case,
        the standard deviation is ``self.sigma0``.

        Returns:
            ``(self.batch_size, len(self.x0))`` array -- contains ``batch_size``
            new solutions to evaluate.
        """
        if self.archive.is_empty():
            parents = np.expand_dims(self.x0, axis=0)
        else:
            parents = [
                self.archive.get_random_elite()[0]
                for _ in range(self.batch_size)
            ]

        return parents + self._rng.normal(scale=self.sigma0,
                                          size=(self.batch_size, len(self.x0)))

    def tell(self, solutions, objective_values, behavior_values):
        """Gives the emitter results from evaluating several solutions.

        These solutions are then inserted into the archive.

        Args:
            solutions (np.ndarray): Array of solutions generated by this
                emitter's :meth:`ask()` method.
            objective_values (np.ndarray): 1D array containing the objective
                function value of each solution.
            behavior_values (np.ndarray): ``(n, <behavior space dimension>)``
                array with the behavior space coordinates of each solution.
        """
        for sol, obj, beh in zip(solutions, objective_values, behavior_values):
            self.archive.add(sol, obj, beh)
