"""Provides EmitterBase."""

import numbers
from abc import ABC

import numpy as np

from ribs._utils import deprecate_bounds


class EmitterBase(ABC):
    """Base class for emitters.

    Every emitter has an :meth:`ask` method that generates a batch of solutions, and a
    :meth:`tell` method that inserts solutions into the emitter's archive. Child classes
    are only required to override :meth:`ask`.

    DQD emitters should also override :meth:`ask_dqd` and :meth:`tell_dqd` methods.

    Args:
        archive (ribs.archives.ArchiveBase): Archive of solutions, e.g.,
            :class:`ribs.archives.GridArchive`.
        solution_dim (int or tuple of int): The dimensionality of solutions produced by
            this emitter.
        lower_bounds (None or array-like): Lower bounds of the solution space. Pass None
            to indicate there are no bounds (i.e., bounds are set to -inf).
        upper_bounds (None or array-like): Upper bounds of the solution space. Pass None
            to indicate there are no bounds (i.e., bounds are set to inf).
        bounds: DEPRECATED.
    """

    def __init__(
        self, archive, *, solution_dim, lower_bounds, upper_bounds, bounds=None
    ):
        deprecate_bounds(bounds)

        self._archive = archive
        self._solution_dim = solution_dim
        self._lower_bounds = (
            np.full(solution_dim, -np.inf, dtype=archive.dtypes["solution"])
            if lower_bounds is None
            else np.asarray(lower_bounds, dtype=archive.dtypes["solution"])
        )
        self._upper_bounds = (
            np.full(solution_dim, np.inf, dtype=archive.dtypes["solution"])
            if upper_bounds is None
            else np.asarray(upper_bounds, dtype=archive.dtypes["solution"])
        )

    @property
    def archive(self):
        """ribs.archives.ArchiveBase: Stores solutions generated by this emitter."""
        return self._archive

    @property
    def solution_dim(self):
        """int or tuple of int: Dimensionality of solutions produced by this emitter."""  # noqa: D403
        return self._solution_dim

    @property
    def lower_bounds(self):
        """numpy.ndarray: ``(solution_dim,)`` array with lower bounds of solution space.

        For instance, ``[-1, -1, -1]`` indicates that every dimension of the solution
        space has a lower bound of -1.
        """
        return self._lower_bounds

    @property
    def upper_bounds(self):
        """numpy.ndarray: ``(solution_dim,)`` array with upper bounds of solution space.

        For instance, ``[1, 1, 1]`` indicates that every dimension of the solution space
        has an upper bound of 1.
        """
        return self._upper_bounds

    def ask(self):
        """Generates a ``(batch_size, solution_dim)`` array of solutions.

        Returns an empty array by default.
        """
        solution_dim = (
            (self.solution_dim,)
            if isinstance(self.solution_dim, numbers.Integral)
            else self.solution_dim
        )
        return np.empty((0, *solution_dim), dtype=self.archive.dtypes["solution"])

    def tell(self, solution, objective, measures, add_info, **fields):
        """Gives the emitter results from evaluating solutions.

        This base class implementation (in :class:`~ribs.emitters.EmitterBase`) does
        nothing by default.

        Args:
            solution (numpy.ndarray): Array of solutions generated by this emitter's
                :meth:`ask()` method.
            objective (numpy.ndarray): 1D array containing the objective function value
                of each solution.
            measures (numpy.ndarray): ``(n, <measure space dimension>)`` array with the
                measure space coordinates of each solution.
            add_info (dict): Data returned from the archive
                :meth:`~ribs.archives.ArchiveBase.add` method.
            fields (keyword arguments): Additional data for each solution. Each argument
                should be an array with batch_size as the first dimension.
        """

    def ask_dqd(self):
        """Generates solutions for which gradient information must be computed.

        The solutions should be a ``(batch_size, solution_dim)`` array.

        This method only needs to be implemented by emitters used in DQD. It returns an
        empty array by default.
        """
        solution_dim = (
            (self.solution_dim,)
            if isinstance(self.solution_dim, numbers.Integral)
            else self.solution_dim
        )
        return np.empty((0, *solution_dim), dtype=self.archive.dtypes["solution"])

    def tell_dqd(self, solution, objective, measures, jacobian, add_info, **fields):
        """Gives the emitter results from evaluating the gradient of the solutions.

        This method is the counterpart of :meth:`ask_dqd`. It is only used by DQD
        emitters.

        Args:
            solution (numpy.ndarray): ``(batch_size, :attr:`solution_dim`)`` array of
                solutions generated by this emitter's :meth:`ask()` method.
            objective (numpy.ndarray): 1-dimensional array containing the objective
                function value of each solution.
            measures (numpy.ndarray): ``(batch_size, measure space dimension)`` array
                with the measure space coordinates of each solution.
            jacobian (numpy.ndarray): ``(batch_size, 1 + measure_dim, solution_dim)``
                array consisting of Jacobian matrices of the solutions obtained from
                :meth:`ask_dqd`. Each matrix should consist of the objective gradient of
                the solution followed by the measure gradients.
            add_info (dict): Data returned from the archive
                :meth:`~ribs.archives.ArchiveBase.add` method.
            fields (keyword arguments): Additional data for each solution. Each argument
                should be an array with batch_size as the first dimension.
        """
