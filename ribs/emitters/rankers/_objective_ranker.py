"""
Provides the ObjectiveRanker
"""
import numpy as np

from ribs.emitters.rankers._ranker_base import RankerBase


class ObjectiveRanker(RankerBase):
    """Ranks the solutions based on the objective values

    This ranker originates in `Fontaine 2020
    <https://arxiv.org/abs/1912.02400>`_ as OptimizingEmitter.
    We rank the solutions solely based on their objective values.
    """

    def rank(self, emitter, archive, solutions, objective_values,
             behavior_values, metadata, add_statuses, add_values):
        """Ranks the soutions based on their objective values.

        Args:
            emitter (ribs.emitters.EmitterBase):
            archive (ribs.archives.ArchiveBase): An archive to use when creating
                and inserting solutions. For instance, this can be
                :class:`ribs.archives.GridArchive`.
            solutions (numpy.ndarray): Array of solutions generated by this
                emitter's :meth:`ask()` method.
            objective_values (numpy.ndarray): 1D array containing the objective
                function value of each solution.
            behavior_values (numpy.ndarray): ``(n, <behavior space dimension>)``
                array with the behavior space coordinates of each solution.
            metadata (numpy.ndarray): 1D object array containing a metadata
                object for each solution.
            add_statuses ():
            add_values ():

        Returns:
            indices: indicate order of the solutions in descending order
        """
        ranking_data = []
        for i, (obj, status) in enumerate(zip(objective_values, add_statuses)):
            added = bool(status)
            ranking_data.append((added, obj, i))
            if added:
                new_sols += 1


        # if self._selection_rule == "filter":
        #     # Sort by whether the solution was added into the archive, followed
        #     # by objective value.
        #     key = lambda x: (x[0], x[1])

        # Sort only by objective value.
        ranking_data.sort(reverse=True, key=lambda x: x[1])
        return [d[2] for d in ranking_data]
